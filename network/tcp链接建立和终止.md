
### tcp协议（概念和介绍）  
#### 特性  
  
tcp是一个可靠的，面向链接的协议。  
tcp（udp也是，所以tcp udp都有一个伪头部）会对整个数据进行校验。  
对失序的报文进行排序。  
面向字节流，可以流量控制 拥塞控制。  

![状态变换图](http://pyblog-10073407.image.myqcloud.com/postimage1511276362)

由于tcp是一个面向链接的协议，所以需要建立一个逻辑上的链接，这个链接的建立过程就是  
三次握手 和 四次挥手。  
从上图可以很清楚的看出tcp链接建立和断开的过程。值得注意的是在socket编程中，是不可以  
从connect状态变到syn_sent状态的（在调用 listen后 无法调用connect）。在建立链接的过程中  
使用seq来保持同步。  

![建立和断开](http://pyblog-10073407.image.myqcloud.com/postimage1511276414)

由于tcp是一个面向链接的协议，所以需要建立一个逻辑上的链接，这个链接的建立过程就是  
三次握手 和 四次挥手。  
从上图可以很清楚的看出tcp链接建立和断开的过程。值得注意的是在socket编程中，是不可以  
从connect状态变到syn_sent状态的（在调用 listen后 无法调用connect）。在建立链接的过程中  
使用seq来保持同步。  

##### 为什么是三次握手？  
因为ip层提供的不可靠的链接，通信的双方为了可靠的建立链接 理论上是最少需要三次的。  
可以试想两次握手时， 客户端发送了一个包就建立连接了，但是这个包在网络上延时了，这个包  
是已经失效的了，但是过了一段时间后服务器又接到了， 服务器就以为还会有数据过来（其实客户  
端早就放弃连接了），就会白白浪费很多资源。  

##### 为什么是四次挥手？
首先TCP是一个全双工的协议， 其次tcp 提供了一个半关闭的一个能力，这个是四次挥手的主要原因。  
举例来说 A-B这一端需要单独断开，B-A这一端也需要断开。这种断开就提供了一种能力，即 A向B断开了，  
但是B还是可以向A发送数据的。A还是可以接收B的数据的。这就是所谓的半关闭和三次握手相比 三次握手  
中的SYN 和 ACK 是可以同时发送回去的。而断开的过程中  ACK 和 FIN 是分开的，这是因为有的数据可  
以还没传完，在一个单向上还需要发送。  


##### 同时打开链接 同时关闭 会如何？
先来看同时打开。双方同时发syn，进入syn_sent状态，当每一段收到syn后进入到syn_recv  
![同时打开](http://pyblog-10073407.image.myqcloud.com/postimage1511964984?imageView2/0/w/450/h/400 "enter image title here")
  再对其进行确认就完成了链接建立。和正常建立链接不同的是需要交换四个报文段。  
 
同时关闭，和正常的关闭不同，双方直接从established发送fin，进入closing，发送ack后进入timewait状态。  
![同时关闭](http://pyblog-10073407.image.myqcloud.com/postimage1511964982?imageView2/0/w/450/h/400 "enter image title here") 
  

##### time_wait close_wait状态？  
先来说closewait状态这个状态只会在被动关闭的一方出现。出现这个状态主要是因为两点：  
1. 应用程序没有正确处理tcp链接的关闭。  
2. 我之前遇到的，在一个程序中同时进行了大量的链接，其中有一些是很活跃的链接，一些是不活跃的  
导致那些不活跃的链接被关闭后，程序没有去处理。  
  
这里引出finwait2定时器的概念，试想有很多的链接被主动关闭了，这些链接没有进行对应的处理导致这个连接被占用着。这时就  
需要一个定时器来解决。超过时间后就完全断开这一端的链接。这时如果客户端反应过来，这个链接就变成了半打开连接（客户端）  
不知道这个链接已经断开了。



##### time_wait状态（等待2msl，msl指的是报文在网络的最大生存时间，ip层中有一个ttl的东西）是主动断开链接的一方会出现的一种状态，  
这种状态出现的原因是因为两点：  
  
第一，确保最后的ack报文到达了对方，防止丢失。  
第二，在time_wait状态下（A的ip， 端口， B的ip， 端口）无法复用。这是为了  
防止来自该链接的延迟报文对这个新开的链接造成影响。可以通过设置SO_REUSEADDR  
来防止。  
time_wait会等待2msl来确保旧的报文不会在网络中出现了。  
 一般来说相同的两个ip 同时建立大量短连接可能是会出现由于time_wait状态引起的资源不够用  
 的情况的。  
 
