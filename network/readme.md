[计算机网络中的一些思想](#思考)


### 思考
##### 网络中比较重要的思想。  

协议的三个要素 语义 语法 时序  
语义 指的就是要做什么。在协议中就是每个报文的控制信息的意思。比如 ip协议中的网络地址就是用来唯一表示一台机器的。  
语法 指的就是一些格式方面的东西。 在协议中就是报文的格式。不同的协议有不同的格式。  
时序 网络中存在很多包，要区分那个时间发生了什么就需要一个这个东西。

#### 复用 和 分用
复用 这个是用在运输层tcp 和 udp用到的一个思想。 在高层的协议通过添加自己的端口号可以都使用tcp 或者 udp 协议。  
分用 当一个数据包到达时还是通过端口号将不同进程需要的数据给发送过去。

#### 分层  
这个是整个体系中最重要的概念。 通过将整个网络划分为合理的层次，底层给上层提供抽象接口，个层只需要关心自己的上层和  
下层降低了很多复杂度。 


### 计算机网络  

上面也提到了计算机中中重要的就是抽象的这个概念，用这个概念来降低复杂度。  
作为一个面向应用的人员来说应该主要关注 运输层以及运输层网上的东西。

七层协议 和 五层协议图  
![五层协议](http://pyblog-10073407.image.myqcloud.com/postimage1511274660?imageView2/0/w/450/h/400 "enter image title here")  

![七层协议](http://pyblog-10073407.image.myqcloud.com/postimage1511274667)  


 

## 应用层


在应用层使用最多的和接触最多的就是http相关的协议了。
归类到pweb文件夹下。

## 运输层

传输层的主要作用在ip层建立的两个主机间的链接上建立两个进程间的链接。  
在这一层主要是两个协议 一个是面向链接的tcp 一个是无连接的udp。  

之前看到的一个问题是 既然ip是无连接的 不可靠的，udp也是无连接的不可靠的，为什么  
要有udp的存在？  
按照我现在的理解 这里的答案主要就是因为ip层建立的是端到端的链接， 是两个主机间的。  
具体到执行的话是主机中的进程执行，而运输层的udp 和 tcp 都有端口这个概念。也就是依靠  
这个端口来执行具体的进程间的通信。


### tcp协议（概念和介绍）  
tcp是一个可靠的，面向链接的协议。要通过很复杂的机制来保证。

#### tcp头部  

以太网首部 - IP首部 - TCP首部 - 应用数据

首先来明确下tcp要做的一些事情，从上面这句话可以看到是一层层封装的。在网络层次结构中，只需要关心  
上层和自己临近的一层。ip层为我们提供了主机和主机间的不可靠链接。 tcp需要提供的就是应用进程间的可靠  
链接。 为了提供具体的应用进程间的链接，使用了16位的端口号。（A的ip，端口， B的ip，端口）构成了一个四元组  
用来标识唯一的一个链接。 由于tcp是面向流的，tcp用32位的序列号和确认号 来标识。 用4位来标识首部长度  
还需要几位的标志位 来标识各种状态。 tcp是可以控制流量的，这个靠窗口来实现。 并且tcp是要对整个报文进行校验的  
以上就是tcp中主要要了解到的字段。 

![tcp头](http://pyblog-10073407.image.myqcloud.com/postimage1511277046)


#### 连接建立和终止  
![状态变换图](http://pyblog-10073407.image.myqcloud.com/postimage1511276362)
![建立和断开](http://pyblog-10073407.image.myqcloud.com/postimage1511276414)

上图分别是tcp协议的状态转换图和tcp三次握手和四次挥手的过程。  

由于tcp是一个面向链接的协议，所以需要建立一个逻辑上的链接，这个链接的建立过程就是  
三次握手 和 四次挥手。  
从上图可以很清楚的看出tcp链接建立和断开的过程。值得注意的是在socket编程中，是不可以  
从connect状态变到syn_sent状态的（在调用 listen后 无法调用connect）。在建立链接的过程中  
使用seq来保持同步。  

##### 为什么是三次握手？  
因为ip层提供的不可靠的链接，通信的双方为了可靠的建立链接 理论上是最少需要三次的。  
可以试想两次握手时， 客户端发送了一个包就建立连接了，但是这个包在网络上延时了，这个包  
是已经失效的了，但是过了一段时间后服务器又接到了， 服务器就以为还会有数据过来（其实客户  
端早就放弃连接了），就会白白浪费很多资源。  

##### 为什么是四次挥手？
首先TCP是一个全双工的协议， 其次tcp 提供了一个半关闭的一个能力，这个是四次挥手的主要原因。  
举例来说 A-B这一端需要单独断开，B-A这一端也需要断开。这种断开就提供了一种能力，即 A向B断开了，  
但是B还是可以向A发送数据的。A还是可以接收B的数据的。这就是所谓的半关闭和三次握手相比 三次握手  
中的SYN 和 ACK 是可以同时发送回去的。而断开的过程中  ACK 和 FIN 是分开的，这是因为有的数据可  
以还没传完，在一个单向上还需要发送。  


##### 同时打开链接 同时关闭 会如何？
先来看同时打开。双方同时发syn，进入syn_sent状态，当每一段收到syn后进入到syn_recv  
再对其进行确认就完成了链接建立。和正常建立链接不同的是需要交换四个报文段。

A ---》B syn j
B ---》A syn k
（上面同时进行）
A ---》B ack k+1
B ---》A ack j+1 
established
断开链接和上面相似。唯一的不同是最后进入time_wait状态。  

##### time_wait close_wait状态？  
time_wait状态是主动断开链接的一方会出现的一种状态，这种状态出现的原因是因为两点  
第一，确保ack报文到达了对方，防止丢失。  
第二，在time_wait状态下（A的ip， 端口， B的ip， 端口）无法复用。这是为了  
防止来自该链接的延迟报文对这个新开的链接造成影响。可以通过设置SO_REUSEADDR  
来防止。  
time_wait会等待2msl来确保旧的报文不会在网络中出现了。  
 一般来说相同的两个ip 同时建立大量短连接可能是会出现由于time_wait状态引起的资源不够用  
 的情况的。  
 
 close_wait状态是被动关闭链接出现的，一般这种情况由应用去管理，断开链接。  
 
 
 
 ##### 
 
 
 
 
 
 ##### 现在有一个问题 为什么设置了 SO_REUSEADDR 这个后可以立即重新启动该链接？  
 



#### 拥塞控制和流量控制

#### 数据流

### udp协议


## ip层

### ip协议


## 数据链路层

## 物理层



























