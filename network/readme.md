[计算机网络中的一些思想](#思考)


### 思考
##### 网络中比较重要的思想。  

协议的三个要素 语义 语法 时序  
语义 指的就是要做什么。在协议中就是每个报文的控制信息的意思。比如 ip协议中的网络地址就是用来唯一表示一台机器的。  
语法 指的就是一些格式方面的东西。 在协议中就是报文的格式。不同的协议有不同的格式。  
时序 网络中存在很多包，要区分那个时间发生了什么就需要一个这个东西。

#### 复用 和 分用
复用 这个是用在运输层tcp 和 udp用到的一个思想。 在高层的协议通过添加自己的端口号可以都使用tcp 或者 udp 协议。  
分用 当一个数据包到达时还是通过端口号将不同进程需要的数据给发送过去。

#### 分层  
这个是整个体系中最重要的概念。 通过将整个网络划分为合理的层次，底层给上层提供抽象接口，个层只需要关心自己的上层和  
下层降低了很多复杂度。 


### 计算机网络  

上面也提到了计算机中中重要的就是抽象的这个概念，用这个概念来降低复杂度。  
作为一个面向应用的人员来说应该主要关注 运输层以及运输层网上的东西。

七层协议 和 五层协议图  
![五层协议](http://pyblog-10073407.image.myqcloud.com/postimage1511274660?imageView2/0/w/450/h/400 "enter image title here")  

![七层协议](http://pyblog-10073407.image.myqcloud.com/postimage1511274667)  


 

## 应用层


在应用层使用最多的和接触最多的就是http相关的协议了。
归类到pweb文件夹下。

## 运输层

传输层的主要作用在ip层建立的两个主机间的链接上建立两个进程间的链接。  
在这一层主要是两个协议 一个是面向链接的tcp 一个是无连接的udp。  

之前看到的一个问题是 既然ip是无连接的 不可靠的，udp也是无连接的不可靠的，为什么  
要有udp的存在？  
按照我现在的理解 这里的答案主要就是因为ip层建立的是端到端的链接， 是两个主机间的。  
具体到执行的话是主机中的进程执行，而运输层的udp 和 tcp 都有端口这个概念。也就是依靠  
这个端口来执行具体的进程间的通信。


### tcp协议（概念和介绍）  
tcp是一个可靠的，面向链接的协议。要通过很复杂的机制来保证。

#### tcp头部  

以太网首部 - IP首部 - TCP首部 - 应用数据

首先来明确下tcp要做的一些事情，从上面这句话可以看到是一层层封装的。在网络层次结构中，只需要关心  
上层和自己临近的一层。ip层为我们提供了主机和主机间的不可靠链接。 tcp需要提供的就是应用进程间的可靠  
链接。 为了提供具体的应用进程间的链接，使用了16位的端口号。（A的ip，端口， B的ip，端口）构成了一个四元组  
用来标识唯一的一个链接。 由于tcp是面向流的，tcp用32位的序列号和确认号 来标识。 用4位来标识首部长度  
还需要几位的标志位 来标识各种状态。 tcp是可以控制流量的，这个靠窗口来实现。 并且tcp是要对整个报文进行校验的  
以上就是tcp中主要要了解到的字段。 

![tcp头](http://pyblog-10073407.image.myqcloud.com/postimage1511277046)


#### 连接建立和终止  
![状态变换图](http://pyblog-10073407.image.myqcloud.com/postimage1511276362)
![建立和断开](http://pyblog-10073407.image.myqcloud.com/postimage1511276414)

上图分别是tcp协议的状态转换图和tcp三次握手和四次挥手的过程。  

由于tcp是一个面向链接的协议，所以需要建立一个逻辑上的链接，这个链接的建立过程就是  
三次握手 和 四次挥手。  
从上图可以很清楚的看出tcp链接建立和断开的过程。值得注意的是在socket编程中，是不可以  
从connect状态变到syn_sent状态的（在调用 listen后 无法调用connect）。在建立链接的过程中  
使用seq来保持同步。  

##### 为什么是三次握手？  
因为ip层提供的不可靠的链接，通信的双方为了可靠的建立链接 理论上是最少需要三次的。  
可以试想两次握手时， 客户端发送了一个包就建立连接了，但是这个包在网络上延时了，这个包  
是已经失效的了，但是过了一段时间后服务器又接到了， 服务器就以为还会有数据过来（其实客户  
端早就放弃连接了），就会白白浪费很多资源。  

##### 为什么是四次挥手？
首先TCP是一个全双工的协议， 其次tcp 提供了一个半关闭的一个能力，这个是四次挥手的主要原因。  
举例来说 A-B这一端需要单独断开，B-A这一端也需要断开。这种断开就提供了一种能力，即 A向B断开了，  
但是B还是可以向A发送数据的。A还是可以接收B的数据的。这就是所谓的半关闭和三次握手相比 三次握手  
中的SYN 和 ACK 是可以同时发送回去的。而断开的过程中  ACK 和 FIN 是分开的，这是因为有的数据可  
以还没传完，在一个单向上还需要发送。  


##### 同时打开链接 同时关闭 会如何？
先来看同时打开。双方同时发syn，进入syn_sent状态，当每一段收到syn后进入到syn_recv  
再对其进行确认就完成了链接建立。和正常建立链接不同的是需要交换四个报文段。

A ---》B syn j
B ---》A syn k
（上面同时进行）
A ---》B ack k+1
B ---》A ack j+1 
established
断开链接和上面相似。唯一的不同是最后进入time_wait状态。  

##### time_wait close_wait状态？  
time_wait状态是主动断开链接的一方会出现的一种状态，这种状态出现的原因是因为两点  
第一，确保ack报文到达了对方，防止丢失。  
第二，在time_wait状态下（A的ip， 端口， B的ip， 端口）无法复用。这是为了  
防止来自该链接的延迟报文对这个新开的链接造成影响。可以通过设置SO_REUSEADDR  
来防止。  
time_wait会等待2msl来确保旧的报文不会在网络中出现了。  
 一般来说相同的两个ip 同时建立大量短连接可能是会出现由于time_wait状态引起的资源不够用  
 的情况的。  
 
 close_wait状态是被动关闭链接出现的，一般这种情况由应用去管理，断开链接。    
 
##### 现在有一个问题 为什么设置了 SO_REUSEADDR 这个后可以立即重新启动该链接？  
在time_wait状态下立马重用链接主要的要选取正确的序号。确保可以识别出一个到达的包是新  
链接的还是旧的链接的。  

##### tcp的序号。  
从上图的tcp头部可以看出，tcp的序号是一个32位的，也就是说最大可以支持0-2**32-1 的取值空间。  
也就是说tcp的序号是循环使用的。对于这种循环使用就要使用取模运算，同时要区分开旧数据和新数据  


 
##### tcp的可靠传输具体是如何实现的？  
理想的传输是：传输信道不出现差错。发送方发送的数据接收方可以来的急接收 处理。  
tcp就是在不可靠的网络中通过一些手段来尽量让传输趋于理想。  
对于上面第一点，数据错了可以通过重传来实现。对于第二点通过控制传输的速度来实现。  
tcp中的实现  

保证可靠传输的最简单的方法是：  
A 发送--》 B  
B 确认--》 A  
  。。。  
   ----出错，丢掉  
A 重传  
  
但是这种方法效率太低了，tcp是通过维持一个窗口来进行控制的。通过一个窗口来进行累计确认  
  
![滑动窗口1](http://pyblog-10073407.image.myqcloud.com/postimage1511616411)  
  
这个窗口中举了一个例子。展示了发送窗口和接收窗口是如何变化的。  
其中  p1-p3是窗口大小  
p2-p1是发送了未被确认的部分  
p3-p2是允许发送，但是还没发送，叫可用窗口。  
窗口是可以收缩的，但是不建议这样子搞。  

![滑动窗口2](http://pyblog-10073407.image.myqcloud.com/postimage1511616434)  
  
发送方的缓存要保存准备给对方发送的数据，和发送了未被确认的数据（为了重传）  
接收方的缓存要保存没有被应用进程处理的数据，还有未按序到达的。  

  
##### tcp 的交互数据流  
试想一种情况，每次传输很少字节的数据。这样的一个报文加上ip头的20个字节，tcp头的20个字节  
实际上真正传输的数据远远小于报文头。在局域网中延迟很小，这种数据是没什么影响的。但是在广域网  
中发送这种数据是可能增加出现拥塞的可能。这个时候就要启动nagle算法，进行一个报文合并，增加网络  
的使用率。  
这种方法通过累计数据减少报文段的数目只适用于低速的网络。如果用在网络速度比较快的环境就会产生延迟。  
具体使用时就要考虑 延迟 和 带宽的取舍了。



 
##### tcp的各种定时器。  
在链接建立的时候如果一直没有得到响应怎么办？  
：有一个链接建立定时器，如果超过定时时间就中止。  
  

如果数据发送后迟迟无回应怎么办？  
：这里要有一个重传定时器，超过时间就重新发送。  

如果对于每一个数据收到就立马确认效率会低，怎么办？  
：延迟ack定时器。将必须确认的但是可以延迟确认的包通过定时，  
看这段时间内有无向对方的数据发送，如果有就进行捎带确认。  

再来考虑一种特殊情况，B向A发送了零窗口的报文后，缓存有了一些空间，B  
又向A发送rwnd为300的报文，这个报文丢掉了。A在等待B发送非零的通知，B 
在等待A发数据，于是出现了死锁，怎么办？  
tcp中通过一个持续计时器，当tcp一方收到对方的零窗口通知就启动，设置的时间  
到了就发送一个零窗口的报文（仅一个字节）激活。  

time_wait定时器？  
这个定时器的时间是两倍的MSL（最大报文生存时间），链接主动关闭的一方启动这个  
定时器。  

fin_wait2定时器？  
考虑一种情况，A向B主动断开链接，B收到fin后并没有返回ack响应（可能B关机了）  
如果A一直等待关闭会导致白白占用一条链接。这时就需要这个定时器来控制。
 
 
 
 


#### 拥塞控制

#### 数据流



### udp协议  

#### 在udp上实现可靠传输？  
udp本身是不可靠传输的。想要实现可靠传输就需要在应用层实现。确保数据可以被对方收到。  
  


#### 什么时候用tcp 什么时候用udp？  

实时性，公平性，带宽 这三点是无法同时满足的。  
UDP也可以实现可靠传输，这种方式放弃了公平性（没有拥塞控制）增加了实时性（不需要三次握手  
来建立链接。）  
在实时性要求高的场合使用udp比较好，比如实时聊天。  
其它一些场合使用tcp，tcp是可以充分利用带宽的。比如 传输文件。。。


## ip层

### ip协议


## 数据链路层

## 物理层



























