### 计算机网络  

上面也提到了计算机中中重要的就是抽象的这个概念，用这个概念来降低复杂度。  
作为一个面向应用的人员来说应该主要关注 运输层以及运输层网上的东西。





#### 连接建立和终止  
![建立和断开](http://pyblog-10073407.image.myqcloud.com/postimage1511276414)

上图分别是tcp协议的状态转换图和tcp三次握手和四次挥手的过程。  



##### 为什么是三次握手？  
因为ip层提供的不可靠的链接，通信的双方为了可靠的建立链接 理论上是最少需要三次的。  
可以试想两次握手时， 客户端发送了一个包就建立连接了，但是这个包在网络上延时了，这个包  
是已经失效的了，但是过了一段时间后服务器又接到了， 服务器就以为还会有数据过来（其实客户  
端早就放弃连接了），就会白白浪费很多资源。  

##### 为什么是四次挥手？
首先TCP是一个全双工的协议， 其次tcp 提供了一个半关闭的一个能力，这个是四次挥手的主要原因。  
举例来说 A-B这一端需要单独断开，B-A这一端也需要断开。这种断开就提供了一种能力，即 A向B断开了，  
但是B还是可以向A发送数据的。A还是可以接收B的数据的。这就是所谓的半关闭和三次握手相比 三次握手  
中的SYN 和 ACK 是可以同时发送回去的。而断开的过程中  ACK 和 FIN 是分开的，这是因为有的数据可  
以还没传完，在一个单向上还需要发送。  


##### 同时打开链接 同时关闭 会如何？
先来看同时打开。双方同时发syn，进入syn_sent状态，当每一段收到syn后进入到syn_recv  
再对其进行确认就完成了链接建立。和正常建立链接不同的是需要交换四个报文段。

A ---》B syn j
B ---》A syn k
（上面同时进行）
A ---》B ack k+1
B ---》A ack j+1 
established
断开链接和上面相似。唯一的不同是最后进入time_wait状态。  

##### time_wait close_wait状态？  
time_wait状态是主动断开链接的一方会出现的一种状态，这种状态出现的原因是因为两点  
第一，确保ack报文到达了对方，防止丢失。  
第二，在time_wait状态下（A的ip， 端口， B的ip， 端口）无法复用。这是为了  
防止来自该链接的延迟报文对这个新开的链接造成影响。可以通过设置SO_REUSEADDR  
来防止。  
time_wait会等待2msl来确保旧的报文不会在网络中出现了。  
 一般来说相同的两个ip 同时建立大量短连接可能是会出现由于time_wait状态引起的资源不够用  
 的情况的。  
 
 close_wait状态是被动关闭链接出现的，一般这种情况由应用去管理，断开链接。    
 
##### 现在有一个问题 为什么设置了 SO_REUSEADDR 这个后可以立即重新启动该链接？  
在time_wait状态下立马重用链接主要的要选取正确的序号。确保可以识别出一个到达的包是新  
链接的还是旧的链接的。  

##### tcp的序号。  
从上图的tcp头部可以看出，tcp的序号是一个32位的，也就是说最大可以支持0-2**32-1 的取值空间。  
也就是说tcp的序号是循环使用的。对于这种循环使用就要使用取模运算，同时要区分开旧数据和新数据  


 
##### tcp的可靠传输具体是如何实现的？  
理想的传输是：传输信道不出现差错。发送方发送的数据接收方可以来的急接收 处理。  
tcp就是在不可靠的网络中通过一些手段来尽量让传输趋于理想。  
对于上面第一点，数据错了可以通过重传来实现。对于第二点通过控制传输的速度来实现。  
tcp中的实现  

保证可靠传输的最简单的方法是：  
A 发送--》 B  
B 确认--》 A  
  。。。  
   ----出错，丢掉  
A 重传  
  
但是这种方法效率太低了，tcp是通过维持一个窗口来进行控制的。通过一个窗口来进行累计确认  
  
![滑动窗口1](http://pyblog-10073407.image.myqcloud.com/postimage1511616411)  
  
这个窗口中举了一个例子。展示了发送窗口和接收窗口是如何变化的。  
其中  p1-p3是窗口大小  
p2-p1是发送了未被确认的部分  
p3-p2是允许发送，但是还没发送，叫可用窗口。  
窗口是可以收缩的，但是不建议这样子搞。  

![滑动窗口2](http://pyblog-10073407.image.myqcloud.com/postimage1511616434)  
  
发送方的缓存要保存准备给对方发送的数据，和发送了未被确认的数据（为了重传）  
接收方的缓存要保存没有被应用进程处理的数据，还有未按序到达的。  

  
##### tcp 的交互数据流  
试想一种情况，每次传输很少字节的数据。这样的一个报文加上ip头的20个字节，tcp头的20个字节  
实际上真正传输的数据远远小于报文头。在局域网中延迟很小，这种数据是没什么影响的。但是在广域网  
中发送这种数据是可能增加出现拥塞的可能。这个时候就要启动nagle算法，进行一个报文合并，增加网络  
的使用率。  
这种方法通过累计数据减少报文段的数目只适用于低速的网络。如果用在网络速度比较快的环境就会产生延迟。  
具体使用时就要考虑 延迟 和 带宽的取舍了。



 
##### tcp的各种定时器。  
在链接建立的时候如果一直没有得到响应怎么办？  
：有一个链接建立定时器，如果超过定时时间就中止。  
  

如果数据发送后迟迟无回应怎么办？  
：这里要有一个重传定时器，超过时间就重新发送。  

如果对于每一个数据收到就立马确认效率会低，怎么办？  
：延迟ack定时器。将必须确认的但是可以延迟确认的包通过定时，  
看这段时间内有无向对方的数据发送，如果有就进行捎带确认。  

再来考虑一种特殊情况，B向A发送了零窗口的报文后，缓存有了一些空间，B  
又向A发送rwnd为300的报文，这个报文丢掉了。A在等待B发送非零的通知，B 
在等待A发数据，于是出现了死锁，怎么办？  
tcp中通过一个持续计时器，当tcp一方收到对方的零窗口通知就启动，设置的时间  
到了就发送一个零窗口的报文（仅一个字节）激活。  

time_wait定时器？  
这个定时器的时间是两倍的MSL（最大报文生存时间），链接主动关闭的一方启动这个  
定时器。  

fin_wait2定时器？  
考虑一种情况，A向B主动断开链接，B收到fin后并没有返回ack响应（B处于close_wait状态，但是B没有进行相应的处理）  
如果A一直等待关闭会导致白白占用一条链接。这时就需要这个定时器来控制。
 
 
#### 拥塞控制  
上面说到了一个窗口的概念，这个窗口主要是用来进行流量控制的。这里提到的拥塞控制也是用来控制流量的，不过和上面的那个概念最  
大的区别是上面的流量控制主要目的是为了使发送方的数据接收方可以来得及接收处理。  
这是一个端到端的概念。  
而这个拥塞控制是一个全局的概念。网络负载大的时候就会出现各种情况，网络的负载可能就会出现问题。这时就需要拥塞控制。  

##### 慢启动  
试想，主机发数据的时候，如果一下子把大量的数据打到网络中，网络可能就无法负载。慢启动的思路是逐渐变大发送窗口。
比如 ，cwnd=1--cwnd=2--cwnd=4--cwnd=8 到达慢开始门限，改用拥塞控制算法。  
cwnd=1--cwnd=2--cwnd=4--cwnd=8 前面的每一段中都是经过一个传输轮次变大的。这里是指数变大。之所以叫慢启动的原因是  
因为是从一个很小值开始启动是，而不是因为增长的速度慢。  

##### 拥塞避免  
当慢启动到达一定程度后就到达慢开始门限，就改用拥塞避免算法，这里开始线性增大。如果出现拥塞（没有按时收到确认）  
就将当前的慢开始门限变为当前cwnd的一半（乘法减小），然后cwnd变为1重新开始。  
cwnd是为了便于理解，实际上是用字节为单位来计算的。  

##### 快重传快恢复  



##### BBR算法



### udp协议  

#### 在udp上实现可靠传输？  
udp本身是不可靠传输的。想要实现可靠传输就需要在应用层实现。确保数据可以被对方收到。  
  





## ip层

### ip协议


## 数据链路层

## 物理层



























